<!doctype html>
<html>
	<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="An open source experimental library for writing your CSS styles in JavaScript. Bypass the cascade and get all the power JavaScript in your styles.">
		<title>Descartes</title>

    <meta property="og:url"                content="https://descartes.io/" />
    <meta property="og:title"              content="Descartes - Write CSS in JavaScript" />
    <meta property="og:description"        content="Descartes is an open source experimental library for writing your CSS styles in JavaScript. Bypass the cascade and get all the power JavaScript in your styles." />
    <meta property="og:type"               content="website">
    <meta property="og:image"              content="https://descartes.io/img/social_card.png" />
    <meta property="og:site_name" content="Descartes - Write CSS in JavaScript">
 
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@jonhmchan">
    <meta name="twitter:creator" content="@jonhmchan">
    <meta name="twitter:title" content="Descartes - Write CSS in JavaScript">
    <meta name="twitter:description" content="Descartes is an open source experimental library for writing your CSS styles in JavaScript. Bypass the cascade and get all the power JavaScript in your styles.">
    <meta name="twitter:image:src" content="https://descartes.io/img/social_card.png">

		<link rel="stylesheet" href="../highlight/styles/rainbow.css">
		<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,200,300,600,700,900' rel='stylesheet' type='text/css'>
		<link href='https://fonts.googleapis.com/css?family=Anonymous+Pro:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
		<script type="text/javascript" src="../dist/descartes.js"></script>
    <link rel="stylesheet" href="../css/font-awesome.min.css">
	</head>
	<body>
		<section class="center">
	      <div class="wrapper">
	      <div class="table-row">
	        <div class="table-col12">
	          <h1>Descartes</h1>
	          <h2>Writing CSS in JavaScript</h2>
	        </div>
	      </div>
	      </div>
	    </section>
	    <section>
	      <div class="wrapper">
	      <div class="table-row">
	        <div class="table-col12">
	          <h2>Hello, world! I'm Jon.</h2>
	          <br/><br/>
	          <div class="row">
	          	<div class="col6">
	          		<img src="../img/so_logo.png" width="50" height="50">
	          		<p><strong><a href="http://stackoverflow.com">Stack Overflow</a></strong><br/>Marketing Engineering Lead</p>
	          		<br/>
	          		<p>I run all engineering support for the Stack Overflow brand. Infrastructure, campaign production, and evangelism. I think a lot about growth and what people think about us.</p>
	          	</div>
	          	<div class="col6">
	          		<img src="../img/bento_logo.png" width="63" height="50">
	          		<p><strong><a href="http://bento.io">Bento</a></strong><br/>Founder</p>
	          		<br/>
	          		<p>My passion project building tools to help self-taught developers find the best places to learn to code. I think a lot about how people learn, especially beginners.</p>
	          	</div>
	          </div>
	        </div>
	      </div>
	      </div>
	    </section>
	    <section>
	      <div class="wrapper">
	      <div class="table-row">
	        <div class="table-col12">
	          <h2>What's on the menu?</h2>
	          <br/><br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>1</h2>
	          		<p><strong>Motivation</strong></p>
	          		<p>What is Descartes? Learn more about the inspiration for this experiment and why I built this library.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>2</h2>
	          		<p><strong>Features</strong></p>
	          		<p>A quick tour of all the things that Descartes can currently do, showing off some of its features.</p>
	          	</div>
	          </div>
	          <br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>3</h2>
	          		<p><strong>How It Works</strong></p>
	          		<p>This is how I actually built the project, and what the approaches were to solving some of techincal issues.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>4</h2>
	          		<p><strong>What's Next</strong></p>
	          		<p>This is still an experiment, and there's a lot to still try out. Find out what I'm still thinking about.</p>
	          	</div>
	          </div>
	        </div>
	      </div>
	      </div>
	    </section>



	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h1>1</h1>
	    			<h2>Motivation</h2>
	    			<p>You've got to be joking right?</p>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Of course! But maybe...</h2>
	    			<br/>
	    			<iframe width="640" height="360" src="https://www.youtube.com/embed/KFwBH2fb2E0?rel=0" frameborder="0" allowfullscreen></iframe>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Writing CSS with JavaScript is crazy, of course!</h2>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>But maybe...</h2>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
			<div class="wrapper">
			<div class="table-row">
				<div class="table-col12">
				  <h2>Are you a wizard?</h2>
				  <br/>
				  <div class="row">
				  	<div class="col9">
				  		<p>Of course, you should use CSS to do your styling whenever possible. If I want to simply vertically align something like a <code>div</code>, this makes absolutely <em>perfect sense</em>.</p>
				  	</div>
				  </div>
				  <div class="row">
			  			<div class="col6">
<pre><code class="css">.verticalAlign {
  position: relative;
  top: 50%;
  transform: translateY(-50%);
}</code></pre>
						</div>
					</div>
					<p>...right? Of course! Of course this makes sense! I do this all the time.</p>
				</div>
			</div>
			</div>
	    </section>
	    <section>
			<div class="wrapper">
			<div class="table-row">
				<div class="table-col9">
					<p><strong>But maybe...that's just stupidly unreadable</strong></p>
					<br/>
			  		<p>Maybe writing CSS makes you feel like you're invoking magical spells and incantations. Maybe if I really wanted to make a <code>div</code> element vertically align, I should be able to do so with some basic math and programming. Something sensible might use references to the DOM like this.</p>
			  		<div class="row">
			  			<div class="col10">
<pre><code class="css">.verticalAlign {
  margin-top: (parent.height - this.height) / 2 + "px";
}</code></pre>
						</div>
					</div>
					<p>But of course not! DOM access and JavaScript in CSS is crazy! I would never do that in a production environment. Of course...</p>
			  	</div>
			</div>
			</div>
	    </section>
	    <section>
			<div class="wrapper">
			<div class="table-row">
				<div class="table-col12">
				  <h2>Cascading S**t Show</h2>
				  <br/>
				  <div class="row">
				  	<div class="col9">
				  		<p>Of course, the cascade in CSS is workable. You've probably wondered why cascading works the way that it does. Why is everything global? Why does specificity denote priority? But it's workable! If you had to write plain CSS lately, it might get a little messy really quickly with all the namespacing and repitition.</p>
				  	</div>
				  </div>
				  <div class="row">
			  			<div class="col6">
<pre><code class="css">html {
  margin: 0;
  padding: 0;
}
html body {
  margin: 0;
  padding: 0;
}
html body section {
  max-width: 800px;
}</code></pre>
						</div>
					</div>
				</div>
			</div>
			</div>
	    </section>
	    <section>
			<div class="wrapper">
			<div class="table-row">
				<div class="table-col9">
		  			<p>On top of that, we have things like LESS and SASS, you say. Nesting rules together lets you get rid of worrying about specificity too much and even gives you  things <em>like</em> variables and mixins. You can turn the CSS we had earlier and use a preprocessor instead. Of course!</p>
				  	<div class="row">
			  			<div class="col6">
<pre><code class="sass">html {
  margin: 0;
  padding: 0;
  body {
    margin: 0;
    padding: 0;
    section {
      max-width: 800px;
    }
  }
}</code></pre>
						</div>
					</div>
					<p>All you need to do is learn a new language and install the preprocessor and do just enough programming to get you by with styling. Easy, right? Of course!</p>
				</div>
			</div>
			</div>
	    </section>
	    <section>
			<div class="wrapper">
			<div class="table-row">
				<div class="table-col9">
					<p><strong>But maybe...we already have JavaScript?</strong>
					<br/>
		  			<p>Maybe we could represent what you want in LESS or SASS in a JavaScript object literal and apply the styles yourself. Maybe you would also get all the nice built-in functionality of JavaScript with variables, loops, conditionals, functions, and you wouldn't need to use another technology pattern completely, maybe?</p>
				  	<div class="row">
				  		<div class="col6">
<pre><code class="sass">// LESS or SASS

html {
  margin: 0;
  padding: 0;
  body {
    margin: 0;
    padding: 0;
    section {
      max-width: 800px;
    }
  }
}</code></pre>
						</div>
			  			<div class="col6">
<pre><code class="javascript">var styles = {
  "html": {
    "margin": 0,
    "padding": 0,
    "body": {
      "margin": 0,
      "padding": 0,
      "section": {
        "max-width": "800px"
      }
    }
  }
}</code></pre>
						</div>
					</div>
					<p>But of course not! Separation of responsibilities! I wouldn't dream of doing that in production! Of course...</p>
				</div>
			</p>
			</div>
	    </section>
		<section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>But maybe...I have an idea</h2>
					<br/><br/>
					<div class="row">
						<div class="col4">
							<p><strong>Thought Experiment</strong></p>
							<p>Again these aren't things I actually believe. I would never do these things in production, but it's certainly worth exploring as an exercise.</p>
						</div>
						<div class="col4">
							<p><strong>Existing Implementations</strong></p>
							<p>This is not the first time people have thought JavaScript should be used for CSS. Most notably, React has similar ideas and AbsurdJS is a precursor to the ideas here.</p>
						</div>
						<div class="col4">
							<p><strong>Recent Conversations</strong></p>
							<p>There are a lot of people talking about what it might mean to <em>not</em> use CSS anymore. One of <a href="https://www.youtube.com/watch?v=iniwPUEbPUM" target="_blank"><strong>my favorite talks</strong></a> is by @fat who created Bootstrap.</p>
						</div>
					</div>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col3">&nbsp;</div>
				<div class="table-col6">
					<h2>Descartes</h2>
					<p>Imagine styling if you had full access to the DOM, full control over the cascade, and all the programming power of JavaScript, without the need for LESS or SASS.</p><br/><br/>
					<strong>index.html</strong>
<pre><code class="javascript">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script type="text/javascript" src="descartes.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;script type="text/javascript" src="styles.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<br/>
			<strong>styles.js</strong>
<pre><code class="javascript">var rand_angle = function() {
  return Math.round(Math.random() * (180) - 90);
};
var rand_rgba = function() {
  return "rgba("+[255,255,255].map(function(x) {
    return Math.round(Math.random() * x);
  }).join()+", 1)"
};

Descartes.add({ // Just put descartes.js in the &lt;head&gt; tag
  "html": {
    "body": { // Nest selectors just like in Sass and Less
      "font-family": "Arial", // Set properties
      "font-size": 10 + 6, // = 16, converts to px
      "$(body).keyup": { // Bind events
        "background": function() { // To certain properties
          return 'linear-gradient('
            + rand_angle().toString() + 'deg,'
            + rand_rgba() + ','
            + rand_rgba() + ')'
        } // ...and use functions to generate property values!
      }
    }
  }
})
</code></pre>
	    	</div>
	    	<div class="table-col3">&nbsp;
	    	</div>
	    	</div>
	    </section>


	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h1>2</h1>
	    			<h2>Features</h2>
	    			<p>What Descartes can do</p>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Basic Application</h2>
	    			<br/>
	    			<p>At its core, Descartes lets you define styles as a JavaScript object literal to be applied to the DOM. There are several ways you can do this, but for small projects, you can apply things pretty directly.</p>

<pre><code class="javascript">Descartes.add({ // Completely inline
  "html": {
    "margin": 0, // Sensible px conversion
    "padding": 0,
    "font-family": "Arial", // Dashed CSS properties
    "body": { // Nesting
    	"margin": 0,
    	"padding": 0,
    	"background": "#fff"
    }
  }
})
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Construction</h2>
	    			<br/>
	    			<p>However, defining a huge object literal doesn't make sense when you have a lot of styles. Breaking your styles apart and constructing them before passing it into the engine makes a lot more sense.</p>

<pre><code class="javascript">var styles = {} // Base style

var html = { // html rules
  "margin": 0,
  "padding": 0,
  "font-family": "Arial"
}

var body = { // body rules
  "margin": 0,
  "padding": 0,
  "background": "#fff"
}

// Do construction
html.body = body
styles.html = html

// Pass into the engine
Descartes.add(styles)
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Flexibility</h2>
	    			<br/>
	    			<p>Breaking your styles apart also gives you a lot more flexibility to do things like share styles and modify them for special cases. Take these slightly different styles for <code>p</code> that has its <code>font-size</code> property changed when nested inside of a <code>section</code></p>

	    			<div class="row">
	    				<div class="col6">
<pre><code class="javascript">var styles = {
  "body": {
  	"margin": 0,
  	"padding": 0,
    "p": {
      "margin-bottom": 15,
      "font-size": 18
    },
    "section": {
      "background": "#fff",
      "p": { // Reused with small changes
        "margin-bottom": 15,
        "font-size": 16 // Modified
      }
    }
  }
}
</code></pre>
						</div>
						<div class="col6">
<pre><code class="javascript">var styles = {}

var body = {
  "margin": 0,
  "padding": 0	
}

var section = {
  "background": "#fff"
}

var p = {
  "margin-bottom": 15,
  "font-size": 18
}

styles.body = body
styles.body.section = section
styles.body.p = p
p["font-size"] = 16
styles.body.section = p // Modified
</code></pre>
						</div>
					</div>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Values</h2>
	    			<br/>
	    			<p>Things get really interesting when you realize you have a lot more control over what values you can set using JavaScript. The first obvious thing you can do is do mathematical manipulations on number values.</p>

<pre><code class="javascript">var styles = {
  ".golden": { // Golden ratio rectangle
    "height": 400,
    "width": 400 * ((1 + Math.sqrt(5)) / 2) // 647.2135955
  },
  "p": {
    "font-size": 16, // sensible px conversion
    "line-height": 1.5 // no px conversion
  }
}

// Pass into the engine
Descartes.add(styles)
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Functions</h2>
	    			<br/>
	    			<p>You can also use JavaScript to describe an entire ruleset for a selector. Take a closer look at the <code>.golden</code> class we had earlier that created a rectangle with golden ratio proportions. What if we wanted to create multiple rectangles of different sizes?</p>
	    			<div class="row">
	    				<div class="col6">
<pre><code class="javascript">function golden(small) {
  return small * ((1 + Math.sqrt(5)) / 2)
}

var styles = {
  ".golden": { // Golden ratio rectangle
    "height": 400,
    "width": golden(400) // 647.2135955
  },
  ".golden2": {
    "height": 600,
    "width": golden(600) // 970.82039325
  }
}

// Pass into the engine
Descartes.add(styles)
</code></pre>
						</div>
						<div class="col6">
<pre><code class="javascript">function goldenRules(small) {
  return {
    "height": small,
    "width": small*((1 + Math.sqrt(5)) / 2)
  }
}

// Or just generate the rules directly
var styles = {
  ".golden": goldenRules(400),
  ".golden2": goldenRules(600)
}

// Pass into the engine
Descartes.add(styles)
</code></pre>
						</div>
					</div>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>DOM Access</h2>
	    			<br/>
	    			<p>JavaScript also gives you DOM access so you can use the properties of elements to do some really interesting things. Here's a naive reimplementation of mobile responsiveness using <code>window.innerWidth</code>.</p>

<pre><code class="javascript">var styles = {
  ".wrapper": { // Responsive wrapper
    "margin": "0 auto",
    "width": (window.innerWidth > 800) ? 800 : "100%"
  }
}

// Pass into the engine
Descartes.add(styles)
</code></pre>

					<p>Now this will actually work for initial load, but it won't actually work when the window resizes. What's happening here is that <code class="javascript">(window.innerWidth > 800) ? 800 : "100%"</code> only evaluates when <code>Descartes.add()</code> is fired, generally, when the document is ready.</p>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Function Values</h2>
	    			<br/>
	    			<p>To give you more fine grain control, you can pass functions as values to any property you define in your styles. You simply return the value you ultimately want to use. The function gets fired on <code>Descartes.add()</code> but you can now re-evaluate the function multiple times during JavaScript execution. This would be the first step to giving you better control.</p>

<pre><code class="javascript">var styles = {
  ".wrapper": { // Responsive wrapper
    "margin": "0 auto",
    "width": function() {
      (window.innerWidth > 800) ? 800 : "100%"
    }
  }
}

// Pass into the engine
Descartes.add(styles)
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Aliases</h2>
	    			<br/>
	    			<p>Once you have functional values, how would you actually access those functions to fire again? You can basically get access to those functions using an alias, which is accessible using <code>Descartes.alias</code>. You just set the alias property of a selector, and you can access the function as a property of that alias:</p>

<pre><code class="javascript">var styles = {
  ".wrapper": {
    "alias": "wrapper", // Descartes.alias.wrapper is created
    "margin": "0 auto",
    "width": function() { // Descartes.alias.wrapper.width()
      (window.innerWidth > 800) ? 800 : "100%"
    }
  }
}

// Pass into the engine
Descartes.add(styles)

// Now you can bind events to styles!
$(window).resize(function() {
  Descartes.alias.wrapper.width()
})
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Using Elements</h2>
	    			<br/>
	    			<p>As an aside, Descartes will also pass in the individual element that is being selected as the first argument to the function you define. So, you can define styles that depend on an element by element basis.</p>

<pre><code class="javascript">var styles = {
  ".verticalAlign": { // Responsive wrapper
    "margin-top": function(elem) { // elem is the individual element
      return (elem.parentElement.height - elem.height) / 2
    }
  }
}

// Pass into the engine
Descartes.add(styles)
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>





	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h1>3</h1>
	    			<h2>How It Works</h2>
	    			<p>Going under the hood</p>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	      <div class="wrapper">
	      <div class="table-row">
	        <div class="table-col12">
	          <h2>Background</h2>
	          <br/><br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>1</h2>
	          		<p><strong>ES2015</strong></p>
	          		<p>This was also an experiment in using ES2015 (or ES6? Eh?). There's a lot of really nice features that made writing Descartes easier.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>2</h2>
	          		<p><strong>Sizzle</strong></p>
	          		<p>The one external dependency I have baked into the library, this is jQuery's selector engine. Open source, and really really tiny.</p>
	          	</div>
	          </div>
	          <br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>3</h2>
	          		<p><strong>Unstable</strong></p>
	          		<p>Stuff is changing here on an almost daily basis. What I'm showing here is the most bleeding edge version of Descartes, and the current docs may not be up-to-date.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>4</h2>
	          		<p><strong>Open Source</strong></p>
	          		<p>I'm looking for any help here if you're interested or have ideas about how to improve the library. There's a lot of stuff I want to explore, and with friends!</p>
	          	</div>
	          </div>
	        </div>
	      </div>
	      </div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2>Sample</h2>
	    			<br/>
	    			<p>Take a look here at the simplest implementation here. I'll walk through each of the steps to show you construction to full style application.</p>

<pre><code class="javascript">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script type="text/javascript" src="descartes.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;script type="text/javascript"&gt;
    Descartes.add({
      "html": {
        "margin": 0,
        "padding": 0,
        "body": {
          "margin": 0,
          "padding": 0,
          "background": "#fff"
        }
      }
    })
  &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	      <div class="wrapper">
	      <div class="table-row">
	        <div class="table-col12">
	          <h2>General Structure</h2>
	          <br/><br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>1</h2>
	          		<p><strong>Construction</strong></p>
	          		<p>How is the style tree constructed? How does Descartes prepare any inputs so they can be applied as styles?</p>
	          	</div>
	          	<div class="col4">
	          		<h2>2</h2>
	          		<p><strong>Flattening</strong></p>
	          		<p>The next step is taking the style tree and turning it into something workable for JavaScript to use.</p>
	          	</div>
	          </div>
	          <br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>3</h2>
	          		<p><strong>Painting</strong></p>
	          		<p>This is where the magic happens: cascading, style application, and event binding.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>4</h2>
	          		<p><strong>Exceptions</strong></p>
	          		<p>There's a bunch of other cool parts to this that are worth mentioning. These are the special exceptions.</p>
	          	</div>
	          </div>
	        </div>
	      </div>
	      </div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.add()</code></h2>
	    			<br/>
	    			<p>This is the typical entry point here. What this does is two things: a <code>merge</code> and the meat of the engine <code>render()</code>. At a high level, <code>add()</code> lets you throw in any valid style tree and merges it in with any other style trees that currently exist in Descartes. <code>render()</code> is what processes the style tree and all the magic.</p>
<pre><code class="javascript">/**
   * Adds another style tree to the existing tree and renders
   * @param {object} tree - the style tree to be added
  */
  add(tree) {
    this.styles = this.merge(tree)
    this.render()
  }
</code></pre>
<pre><code class="javascript">/**
   * Merges a style tree with another tree
   * @param {object} tree - the style tree to be merged in
   * @param {object} target - the target style tree, sensibly defaults to this.styles
   * @return {object} the resulting merged tree
  */
  merge(tree, target = this.styles) {
    if (typeof tree !== 'object') return target
    if (Object.keys(tree).length === 0) return target
    let result = Object.assign({}, target)
    for (let key in tree) {
      if (tree.hasOwnProperty(key)) {
        let subtree = tree[key]
        if (target.hasOwnProperty(key)) {
          let targetSubtree = target[key]
          let treeType = typeof subtree
          if (treeType === typeof targetSubtree) {
            switch (treeType) {
              case 'object':
                result[key] = this.merge(subtree, targetSubtree)
                break
              case 'string':
                result[key] = subtree
                break
              case 'array':
                result[key] = subtree.concat(targetSubtree)
                break
              default:
                console.error("Merge failed.")
            }
          } else {
            let targetType = typeof targetSubtree
            if (this.isProperty(key)) {
              result[key] = subtree
            } else {
              console.error("Merge failed.")
            }
          }
        } else {
          result[key] = subtree
        }
      }
    }
    return result
  }
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.render()</code></h2>
	    			<br/>
	    			<p><code>render()</code> is where the magic happens. At a high level, this takes the style tree that Descartes knows about using <code>add()</code> and applies all the styles accordingly. You can see the major functions here:</p>
<pre><code class="javascript">/**
  * Based on the style tree passed to the engine, applies all styles
  */
  render() {
    this.flatten()
    this.bindAliases()
    this.cascade()
    this.paint()
    this.bindListeners()
  }
</code></pre>

	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.flatten()</code></h2>
	    			<br/>
	    			<p><code>flatten()</code> takes your deep style tree that is represented as an object literal and turns it into a "flat" object stored in <code>Descartes.mapping</code> with the DOM selector as a key and all the information about that selector as a value. It would do this:</p>
					<div class="row">
	    				<div class="col6">
<pre><code class="javascript">{
  "html": {
    "margin": 0,
    "padding": 0,
    "body": {
      "background": "#fff",
      "p": {
        "font-size": 12
      }
    }
  }
}
</code></pre>
						</div>
						<div class="col6">
<pre><code class="javascript">{
  "html": {
    "priority": 0,
    "alias": null,
    "rules": {
      "margin": 0,
      "padding": 0
    }
  },
  "html body": {
    "priority": 1,
    "alias": null,
    "rules": {
      "background": "#fff"
    }
  },
  "html body p": {
    "priority": 2,
    "alias": null,
    "rules": {
      "font-size": 12
    }
  }
}
</code></pre>
						</div>
					</div>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.mapping</code></h2>
	    			<br/>
	    			<p>With a proper <code>Descartes.mapping</code> after <code>flatten()</code>, all we have to do now is loop through each of the keys and do the heavy work: alias binding, cascading, and style application:</p>
<pre><code class="javascript">{
  "html": {
    "priority": 0,
    "alias": null,
    "rules": {
      "margin": 0,
      "padding": 0
    }
  },
  "html body": {
    "priority": 1,
    "alias": null,
    "rules": {
      "background": "#fff"
    }
  },
  "html body p": {
    "priority": 2,
    "alias": null,
    "rules": {
      "font-size": 12
    }
  }
}
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.bindAliases()</code></h2>
	    			<br/>
	    			<p>Alias binding is pretty straightforward. Basically, you are setting the properties of an object in <code>Descartes.alias</code> to be functions you can use as callbacks:</p>
<pre><code class="javascript">/**
   * Creates aliases for listener functions
  */
  bindAliases() {
    for (let selector in this.mappings) {
      let mapping = this.mappings[selector]
      let alias = mapping.alias
      if (this.alias.hasOwnProperty(alias) &amp;&amp; alias !== null) {
        console.error("An alias of the name '" + alias + "' already exists")
      } else {
        this.alias[alias] = {}
        let listeners = {}
        for (let property in mapping.rules) {
          let value = mapping.rules[property]
          if (typeof value === 'function') {
            let ruleset = {}
            ruleset[property] = value
            listeners[property] = () => {
              this.applyRuleset(selector, ruleset)
              this.paint()
              return true
            }
          }
        }
        this.alias[alias] = listeners
      }
    }
  }
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.cascade()</code></h2>
	    			<br/>
	    			<p>Going back to the style application portion, <code>cascade()</code> goes through <code>Descartes.mapping</code> and tries to create an ordered list of rules to apply based on the rules' priority. This essentially mimics what CSS cascading does.</p>
<pre><code class="javascript">  /**
   * Prioritizes and cascades the style tree for the entire document
  */
  cascade() {
    let prioritizedList = Array.apply(null, Array(this.mappingsPriority + 1)).map(() => { return [] })
    for (let key in this.mappings) {
      let mapping = this.mappings[key]
      prioritizedList[mapping.priority].push([key, mapping.rules])
    }
    prioritizedList.map(set => {
      set.map(mapping => {
        this.applyRuleset(mapping[0], mapping[1])
      })
    })
  }
</code></pre>
				<p>After the rules are prioritized (or cascaded overall), <code>applyRuleset(selector, rules)</code> is fired in the order of their priority.</p> 
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.applyRuleset()</code></h2>
	    			<br/>
	    			<p>At this point, Descartes starts interacting with the DOM. Using Sizzle, it tries to get the relevant DOM elements for the rule using <code>find()</code> and creates a <code>data-descartes</code> attribute for each element. As the rules get applied, that <code>data-descartes</code> attribute keeps getting built up until the final ruleset for that element is constructed.</p>
<pre><code class="javascript">/**
   * Apply a ruleset for a certain selector into the selector's nodes
   * @param {string} selector - the selector string i.e. "html body .thing"
   * @param {object} ruleset - the full style ruleset to be applied
  */
  applyRuleset(selector = null, ruleset = null) {
    if (selector === null || ruleset === null) return false
    if (this.hasPsuedo(selector) &amp;&amp; this.applyPsuedo(selector, ruleset)) return true
    let elems = this.find(selector.toString())
    if (elems.length === 0) return false
    elems.map(elem => {
      let style = elem.getAttribute('data-descartes')
      if (typeof style === 'undefined') return
      style = (style === null) ? {} : JSON.parse(style)
      let computed = {}
      for (let property in ruleset) {
        computed[property] = this.computeRule(property, ruleset[property], elem)
      }
      style = Object.assign(style, computed)
      elem.setAttribute('data-descartes', JSON.stringify(style))
    })
  }
</code></pre>
				<p>If you look at the HTML elements for the source code, you'll see that <code>data-descartes</code> attribute there when you are debugging, and even watch it change for any elements that you bound an event to using <code>Descartes.alias</code></p>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.computeRule()</code></h2>
	    			<br/>
	    			<p>It's also mentioning that <code>computeRule()</code> does some really cool stuff here like evaluating functional values in properties, doing pixel inference, and string escaping.</p>
<pre><code class="javascript">/**
   * Apply a ruleset for a certain selector
   * @param {string} property - the name of the property i.e. "border", "margin", etc.
   * @param {object} value - the unparsed value of the rule, a function, string, or number
   * @param {object} elem - the DOM element that the value function should use, if passed
   * @return {string, bool} the valid CSS property value, otherwise false
  */
  computeRule(property, value, elem = null) {
    // If the value is a function, evaluate the function to get the computed value
    if (typeof value === 'function') {
      try {
        value = value(elem)
      }
      catch(e) {
        return false
      }
    }
    if (value === null) return null
    if (value === undefined) return null
    let except = this.pxExceptions
    if (Number(value) === value &amp;&amp; except.indexOf(property) < 0) {
      return value.toString() + "px"
    }
    if (property === 'content') {
      return "'" + value.toString() + "'"
    }
    return value.toString()
  }
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.paint()</code></h2>
	    			<br/>
	    			<p>Finally, with all the cascaded, computed values set in each of the elements, <code>paint()</code> fires which goes through all the elements and applies the <code>style</code> attribute using the information in <code>data-descartes</code>:</p>
<pre><code class="javascript">/**
   * Apply inline styles for all finalized rules
  */
  paint() {
    let all = this.find("*")
    all.map(x => {
      let style = x.getAttribute('data-descartes')
      if (typeof style === 'undefined' || style === null) return
      x.setAttribute('style', this.createStyleString(JSON.parse(style), x))
    })
  }
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h2><code>Descartes.createStyleString()</code></h2>
	    			<br/>
	    			<p>An interesting detail here is how <code>createStyleString()</code> also uses <code>computeRule()</code> to do the actual string construction.</p>
<pre><code class="javascript">/**
   * Generate valid CSS ruleset as a string
   * @param {object} ruleset - a full ruleset to be converted
   * @param {object} elem - the DOM node to evaluate any functional values on
   * @return {string} the final CSS ruleset string
  */
  createStyleString(ruleset, elem = null) {
    let style = ""
    for (let property in ruleset) {
      let value = ruleset[property];
      let computedRule = this.computeRule(property, value, elem)
      if (computedRule) style += property + ": " + computedRule + "; "
    }
    style = style.slice(0, -1);
    return style
  }
</code></pre>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	      <div class="wrapper">
	      <div class="table-row">
	        <div class="table-col12">
	          <h2>Extras</h2>
	          <br/><br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>1</h2>
	          		<p><strong>DOM Hiding</strong></p>
	          		<p>The first thing that Descartes does is actually hide the entire DOM until the first initial paint is fired, so there's no flashing.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>2</h2>
	          		<p><strong>Stylesheet</strong></p>
	          		<p>With <code>createStyleString()</code> there is also a way to create an actual stylesheet to use as a backup.</p>
	          	</div>
	          </div>
	          <br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>3</h2>
	          		<p><strong>Compatibility</strong></p>
	          		<p>Because Descartes is just scoped to actual styling but is transparent about event binding and paint control, it plays nice.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>4</h2>
	          		<p><strong>Extensibility</strong></p>
	          		<p>You can start to see some really cool entry points to do prefixing, custom properties, etc.</p>
	          	</div>
	          </div>
	        </div>
	      </div>
	      </div>
	    </section>
	    





	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h1>4</h1>
	    			<h2>What's Next</h2>
	    			<p>Things rockin' my noggin</p>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <section>
	      <div class="wrapper">
	      <div class="table-row">
	        <div class="table-col12">
	          <h2>Ideas</h2>
	          <br/><br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>1</h2>
	          		<p><strong>Performance</strong></p>
	          		<p>The number one thing on my mind is how to speed up Descartes. Workers, backups, and hardware acceleration are all on my mind.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>2</h2>
	          		<p><strong>Ecosystem</strong></p>
	          		<p>Could Descartes open up the door to allow for custom rules, libraries, and other extensions built on it?</p>
	          	</div>
	          </div>
	          <br/>
	          <div class="row">
	          	<div class="col4">
	          		<h2>3</h2>
	          		<p><strong>Event Binding</strong></p>
	          		<p>I've wavered back and forth on this so many times, but what's the scope here? Things like responsiveness seem to be in that space.</p>
	          	</div>
	          	<div class="col4">
	          		<h2>4</h2>
	          		<p><strong>Cascading</strong></p>
	          		<p>I don't think cascading is perfect here, but could it be improved without using specificity as the guiding principle?</p>
	          	</div>
	          </div>
	        </div>
	      </div>
	      </div>
	    </section>
	    <section class="center">
	    	<div class="wrapper">
	    	<div class="table-row">
	    		<div class="table-col12">
	    			<h1>Thanks</h1>
	    			<h2><i class="fa fa-twitter"></i> jonhmchan</h2>
	    			<br/><br/>
	    			<div class="row">
	    				<div class="col4">
	    					<p><strong>Still experimenting</strong></p>
	    					<p>I'm really looking for feedback, even really crazy ones.</p>
	    				</div>
	    				<div class="col4">
	    					<p><strong>Contribute on GitHub</strong></p>
	    					<p>If this really interests you, take a look at the code.</p>
	    				</div>
	    				<div class="col4">
	    					<p><strong>Follow me on Twitter</strong></p>
	    					<p>I would love to keep the conversation going</p>
	    				</div>
	    			</div>
	    		</div>
	    	</div>
	    	</div>
	    </section>
	    <p><a id="twitter" href="https://twitter.com/jonhmchan"><i class="fa fa-twitter"></i> jonhmchan</a></p>
	</body>
	<script type="text/javascript" src="../jquery-2.2.0.min.js"></script>
	<script type="text/javascript" src="../dist/plato.js"></script>
	<script type="text/javascript" src="../dist/slides.js"></script>

	<script type="text/javascript" src="../highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	
	  ga('create', 'UA-73962501-1', 'auto');
	  ga('send', 'pageview');
	
	</script>
</html>
